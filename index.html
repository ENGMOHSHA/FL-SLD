<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BIRDEYE - Network Intelligence</title>

  <!-- External libraries -->
  <script src="https://cdn.jsdelivr.net/npm/cytoscape@3.20.0/dist/cytoscape.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.1.70/pdfmake.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.1.70/vfs_fonts.js"></script>
  <script src="https://unpkg.com/file-saver@2.0.5/dist/FileSaver.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      display: flex; height: 100vh;
      font-family: 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      overflow: hidden;
    }

    /* Side Panel */
    #leftSection {
      display: none; flex-direction: column; gap: 12px; padding: 20px;
      height: 100vh; width: 360px; position: fixed; top: 0; left: 0;
      background: rgba(255, 255, 255, 0.98); backdrop-filter: blur(10px);
      z-index: 1000; box-shadow: 4px 0 20px rgba(0, 0, 0, 0.15);
      overflow-y: auto;
    }
    #leftSection.show { display: flex; }

    #burgerButton {
      position: fixed; top: 20px; left: 20px; cursor: pointer;
      z-index: 2000;
      background: white; width: 45px; height: 45px; border-radius: 10px;
      display: flex; align-items: center; justify-content: center;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); font-size: 20px;
      pointer-events: auto; user-select: none;
    }

    .brand {
      font-size: 24px; font-weight: bold; text-align: center; margin-bottom: 2px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    }
    .dev-credit { font-size: 11px; text-align: center; color: #764ba2; font-weight: 600; margin-bottom: 10px; }

    .panel-section { background: #ffffff; border: 2px solid #eef0ff; border-radius: 10px; padding: 12px; }
    .section-title { font-size: 11px; font-weight: 800; text-transform: uppercase; color: #666; letter-spacing: 0.5px; margin-bottom: 8px; }
    .divider { height: 1px; background: #eee; margin: 10px 0; }

    select, input[type="text"] {
      padding: 10px; border: 1px solid #ddd; border-radius: 6px;
      font-size: 13px; width: 100%; outline: none; background: #fff;
    }
    button {
      padding: 12px; border: none; border-radius: 6px; font-weight: 700;
      cursor: pointer; color: white; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      font-size: 11px; text-transform: uppercase;
    }
    #drawBtn { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); }
    #drawBtn:disabled { opacity: 0.3; cursor: not-allowed; }

    .btn-row { display: flex; gap: 8px; }
    .btn-outline { background: #555; }
    .btn-danger { background: #ff4b2b; }
    .btn-info { background: #4facfe; }

    /* Sliders (no numeric output shown) */
    .slider-row { display: flex; flex-direction: column; gap: 6px; margin: 8px 0; }
    .slider-label { font-size: 12px; color: #444; font-weight: 600; }
    input[type="range"] {
      -webkit-appearance: none; width: 100%; height: 6px; border-radius: 5px; background: #e8eaf6; outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none; appearance: none; width: 14px; height: 14px; border-radius: 50%;
      background: #667eea; cursor: pointer; border: 2px solid white; box-shadow: 0 0 2px rgba(0,0,0,0.2);
    }
    input[type="range"]::-moz-range-thumb {
      width: 14px; height: 14px; border-radius: 50%;
      background: #667eea; cursor: pointer; border: 2px solid white;
    }

    #gridFilterContainer {
      height: 250px; min-height: 250px;
      overflow-y: auto; background: #ffffff; padding: 8px;
      border-radius: 8px; border: 2px solid #667eea;
    }
    .grid-item { display: flex; align-items: center; gap: 10px; padding: 8px; font-size: 13px; border-bottom: 1px solid #f0f0f0; }
    .grid-item:hover { background: #f0f4ff; }

    #status { font-size: 10px; text-align: center; font-weight: bold; color: #764ba2; padding-bottom: 5px; }

    #cy {
      flex-grow: 1; margin: 20px 20px 20px 80px; background: white;
      border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,0.1);
      position: relative; z-index: 1;
    }

    /* Tooltip */
    #tooltip {
      position: fixed;
      display: none;
      max-width: 260px;
      background: rgba(0,0,0,0.85);
      color: #fff;
      padding: 8px 10px;
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.25);
      font-size: 12px;
      line-height: 1.35;
      z-index: 3000;
      pointer-events: none;
      white-space: pre-line;
    }
  </style>
</head>
<body>

  <div id="burgerButton">â˜°</div>

  <div id="leftSection">
    <div class="brand">ðŸ¦… BIRDEYE</div>
    <div class="dev-credit">Developed by Eng. Mohamad Shaban</div>
    <div id="status">Preparingâ€¦</div>

    <!-- 1) Project Selection -->
    <div class="panel-section">
      <div class="section-title">1) Project Selection</div>
      <select id="projectList">
        <option disabled selected>Select a Project...</option>
      </select>
      <div class="divider"></div>
      <div id="preloadStatus" style="font-size:12px; color:#666;"></div>
    </div>

    <!-- 2) Filter by Grid -->
    <div class="panel-section">
      <div class="section-title">2) Filter by Grid Station</div>
      <input type="text" id="gridSearchInput" placeholder="Search grids...">
      <div style="display:flex; align-items:center; gap:8px; padding:6px 0;">
        <input type="checkbox" id="selectAllGrids">
        <label for="selectAllGrids" style="font-size:12px; font-weight: 600; color:#444;">Select All (visible)</label>
      </div>
      <div id="gridFilterContainer">
        <p id="emptyMsg" style="font-size:11px; color:#aaa; text-align:center; margin-top:40px;">
          select project to load grids
        </p>
      </div>
      <div class="btn-row" style="margin-top:8px;">
        <button id="applyFilterBtn" class="btn-info" style="flex:1;">Apply</button>
        <button id="resetFilterBtn" class="btn-danger" style="flex:1;">Reset</button>
      </div>
    </div>

    <!-- 3) Feeder Search -->
    <div class="panel-section">
      <div class="section-title">3) Feeder Search</div>
      <label for="gridForFeederSearch" style="font-size:12px; color:#444;">Select Grid Station</label>
      <select id="gridForFeederSearch">
        <option value="" selected disabled>Choose gridâ€¦</option>
      </select>

      <div style="height:8px;"></div>

      <label for="feederList" style="font-size:12px; color:#444;">Select Feeder</label>
      <select id="feederList">
        <option value="" selected disabled>Choose feederâ€¦</option>
      </select>

      <div class="btn-row" style="margin-top:8px;">
        <button id="searchFeederBtn">Search & Highlight</button>
      </div>
    </div>

    <!-- 4) Graph Actions -->
    <div class="panel-section">
      <div class="section-title">4) Graph Actions</div>
      <button id="drawBtn" disabled>DRAW FL-SLD</button>
    </div>

    <!-- ðŸ†• Graph Handling -->
    <div class="panel-section">
      <div class="section-title">Graph Handling</div>

      <!-- Rectify button -->
      <div class="btn-row" style="margin-bottom:8px;">
        <button id="rectifyLoopsBtn" class="btn-outline" title="Rectangularize & Planarize Loops">Rect Loop</button>
      </div>

      <!-- Orientation radios -->
      <div style="margin:6px 0 10px 0;">
        <div class="slider-label" style="margin-bottom:6px;">Loop Orientation (for 3â€“4 feeders)</div>
        <label style="font-size:12px; margin-right:14px;">
          <input type="radio" name="smallLoopOrient" value="vertical" checked> Vertical
        </label>
        <label style="font-size:12px;">
          <input type="radio" name="smallLoopOrient" value="horizontal"> Horizontal
        </label>
      </div>

      <!-- Sliders (no numeric values shown) -->
      <div class="slider-row">
        <div class="slider-label">Loop Spacing</div>
        <input id="ui_minGap" type="range" min="16" max="80" step="2" value="36"/>
      </div>

      <div class="slider-row">
        <div class="slider-label">Grid Expansion Limit</div>
        <input id="ui_maxGrowLimit" type="range" min="12" max="60" step="1" value="30"/>
      </div>

      <div class="slider-row" style="margin-bottom:0;">
        <div class="slider-label">Autoâ€‘Fix Depth</div>
        <input id="ui_relocMoves" type="range" min="50" max="600" step="10" value="200"/>
      </div>
    </div>

    <!-- 5) Export -->
    <div class="panel-section">
      <div class="section-title">5) Export</div>
      <div class="btn-row">
        <button id="exportPdfBtn" class="btn-outline" style="flex:1;">PDF</button>
        <button id="exportPngBtn" class="btn-outline" style="flex:1;">PNG</button>
      </div>
    </div>
  </div>

  <div id="cy"></div>

  <!-- Tooltip -->
  <div id="tooltip"></div>

  <!-- SCRIPT 1: Burger only -->
  <script>
    (function(){
      function toggleLeftSection(){
        var ls = document.getElementById('leftSection');
        var showing = (ls.style.display === 'flex' || ls.classList.contains('show'));
        ls.style.display = showing ? 'none' : 'flex';
        if (!showing) { ls.classList.add('show'); } else { ls.classList.remove('show'); }
      }
      window.toggleLeftSection = toggleLeftSection;
      document.addEventListener('DOMContentLoaded', function(){
        var burger = document.getElementById('burgerButton');
        if (burger) { burger.addEventListener('click', toggleLeftSection); }
      });
    })();
  </script>

  <!-- SCRIPT 2: Main app (ES5-friendly) -->
  <script>
    /* -----------------------------
     * Global state & constants
     * ---------------------------*/
    var cy = null;
    var selectedGrids = [];
    var activeProjectName = '';
    var activeProjectData = { nodes: [], edges: [] };
    var projectDataCache = {}; // name -> {nodes:Array, edges:Array}

    var DEFAULT_LAYOUT = { name: 'cose', padding: 30, animate: true };
    var smallLoopOrientation = 'vertical'; // 'vertical' | 'horizontal'

    /* -----------------------------
     * Utilities & Sanitizers
     * ---------------------------*/
    function norm(v){ return (v == null ? '' : (''+v)).replace(/\uFEFF/g,'').trim(); }
    function setStatus(msg){ var el = document.getElementById('status'); if (el) el.innerText = msg; }

    function fetchTextOrThrow(path){
      return fetch(path).then(function(res){
        if (!res.ok) throw new Error('Failed to fetch ' + path);
        return res.text();
      });
    }
    function parseCSVToArray(csvText){ return Papa.parse(csvText, { skipEmptyLines: true }).data; }

    // Allowed shapes (subset of Cytoscape shapes)
    var KNOWN_SHAPES = {
      'ellipse':1, 'round-rectangle':1, 'rectangle':1, 'triangle':1, 'diamond':1,
      'hexagon':1, 'heptagon':1, 'octagon':1, 'star':1, 'vee':1, 'pentagon':1,
      'round-pentagon':1, 'round-hexagon':1, 'round-triangle':1, 'round-diamond':1
    };
    function safeShape(raw){
      if (!raw) return '';
      var s = (''+raw).trim().toLowerCase();
      if (s === 'circle') s = 'ellipse'; // normalize invalid value
      if (KNOWN_SHAPES[s]) return s;
      return ''; // omit mapping; default style applies
    }
    function safeColor(raw){
      var c = (raw || '').trim();
      if (/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(c) || /^rgba?\(/i.test(c) || /^hsla?\(/i.test(c)) return c;
      return '#8faadc';
    }

    function getBaseStyle(){
      return [
        // Default node style (safe fallback; no mapping here)
        { selector:'node', style:{
            'shape': 'ellipse',
            'background-color':'data(color)',
            'label':'data(label)',
            'width':35, 'height':35,
            'text-valign':'center',
            'font-size':8, 'color':'#000',
            'text-outline-width':1, 'text-outline-color':'#fff',
            'border-width':1, 'border-color':'#333'
        }},
        // Apply shape only if the data field exists
        { selector: 'node[shape]', style: { 'shape': 'data(shape)' }},

        // Edges & highlight
        { selector:'edge', style:{ 'width':2, 'line-color':'#999', 'curve-style':'bezier' }},
        { selector:'node.cy-highlighted', style:{ 'border-width':6, 'border-color':'#FFD700' } }
      ];
    }

    /* -----------------------------
     * Build elements (normalize ALL fields)
     * ---------------------------*/
    function buildAllElementsFromActiveProject(){
      var allNodes = [];
      for (var i=1; i<activeProjectData.nodes.length; i++){
        var row = activeProjectData.nodes[i]; if (!row) continue;
        var id = norm(row[0]);
        var label = norm(row[1]);
        var shape = safeShape(norm(row[2]));
        var color = safeColor(norm(row[3]));
        var grid = norm(row[4]);
        var load = (row.length > 5) ? norm(row[5]) : '';

        var data = { id:id, label:label, color:color, grid:grid, load:load };
        if (shape) data.shape = shape; // only set if valid

        allNodes.push({ data: data });
      }
      var allEdges = [];
      for (var j=1; j<activeProjectData.edges.length; j++){
        var erow = activeProjectData.edges[j]; if (!erow) continue;
        allEdges.push({ data: { id: norm(erow[0]), source: norm(erow[1]), target: norm(erow[2]) } });
      }
      return { nodes: allNodes, edges: allEdges };
    }

    /* -----------------------------
     * Tooltip helpers
     * ---------------------------*/
    var _tooltipNodeId = null;

    function showTooltipForNode(node){
      var t = document.getElementById('tooltip');
      if (!t || !cy || !node || !node.isNode || !node.isNode()) return;

      var label = norm(node.data('label'));
      var grid  = norm(node.data('grid'));
      var load  = norm(node.data('load'));

      var parts = [ 'Feeder: ' + label, 'Grid: ' + grid ];
      if (load) parts.push('Load: ' + load);
      t.textContent = parts.join('\n');

      var rp = node.renderedPosition();
      var rect = cy.container().getBoundingClientRect();
      var offsetX = 14, offsetY = -10;
      var left = Math.round(rect.left + rp.x + offsetX);
      var top  = Math.round(rect.top  + rp.y + offsetY);

      t.style.left = left + 'px';
      t.style.top  = top  + 'px';
      t.style.display = 'block';

      _tooltipNodeId = node.id();
    }
    function hideTooltip(){ var t = document.getElementById('tooltip'); if (t){ t.style.display='none'; } _tooltipNodeId = null; }
    function updateTooltipPositionIfVisible(){
      if (!_tooltipNodeId || !cy) return;
      var node = cy.getElementById(_tooltipNodeId);
      if (node && node.length){ showTooltipForNode(node); } else { hideTooltip(); }
    }

    function onNodeTap(evt){ showTooltipForNode(evt.target); }
    function onCoreTap(evt){ if (evt.target === cy) hideTooltip(); }
    function onViewportChange(){ updateTooltipPositionIfVisible(); }

    function attachCyTooltipHandlers(){
      if (!cy) return;
      cy.off('tap', 'node', onNodeTap);
      cy.off('tap', onCoreTap);
      cy.off('zoom', onViewportChange);
      cy.off('pan', onViewportChange);
      cy.off('dragfree', onViewportChange);
      cy.off('position', onViewportChange);

      cy.on('tap', 'node', onNodeTap);
      cy.on('tap', onCoreTap);
      cy.on('zoom', onViewportChange);
      cy.on('pan', onViewportChange);
      cy.on('dragfree', onViewportChange);
      cy.on('position', onViewportChange);
    }

    /* -----------------------------
     * Render full graph
     * ---------------------------*/
    function ensureFullGraphRenderedAsync(done){
      var data = buildAllElementsFromActiveProject();
      var style = getBaseStyle();
      if (!cy){
        cy = cytoscape({ container: document.getElementById('cy'), elements: data, style: style, layout: DEFAULT_LAYOUT });
        cy.one('layoutstop', function(){ if (typeof done === 'function') done(); });
        attachCyTooltipHandlers();
      } else {
        cy.stop(); cy.elements().remove(); cy.style().fromJson(style).update();
        cy.add(data.nodes.concat(data.edges));
        var layout = cy.layout(DEFAULT_LAYOUT);
        cy.one('layoutstop', function(){ if (typeof done === 'function') done(); });
        layout.run();
        attachCyTooltipHandlers();
      }
    }

    /* -----------------------------
     * Grid filter list
     * ---------------------------*/
    function renderGridFilters(){
      var container = document.getElementById('gridFilterContainer');
      container.innerHTML = '';
      if (!activeProjectData.nodes || activeProjectData.nodes.length === 0){
        container.innerHTML = '<p style="font-size:11px;color:#aaa;text-align:center;margin-top:40px;">Select a project to load grids</p>';
        return;
      }
      var map = {};
      for (var i=1; i<activeProjectData.nodes.length; i++){
       norm(row[4]); if (g) map[g] = true;
      }
      var grids = Object.keys(map).sort();
      if (grids.length === 0){
        container.innerHTML = '<p style="font-size:11px;color:#aaa;text-align:center;margin-top:40px;">No grids found in nodes CSV (column index 4)</p>';
        return;
      }
      for (var k=0; k<grids.length; k++){
        var grid = grids[k];
        var div = document.createElement('div');
        div.className = 'grid-item';
        div.innerHTML = '<input type="checkbox" class="grid-chk" value="'+grid+'"> <span class="grid-name-label">'+grid+'</span>';
        container.appendChild(div);
      }
    }
    function filterGridList(){
      var val = norm(document.getElementById('gridSearchInput').value).toLowerCase();
      var items = document.querySelectorAll('.grid-item');
      for (var i=0; i<items.length; i++){
        var label = items[i].querySelector('.grid-name-label');
        var text = label ? norm(label.innerText).toLowerCase() : '';
        items[i].style.display = (text.indexOf(val) !== -1) ? 'flex' : 'none';
      }
    }
    function toggleSelectAllHandler(){
      var source = document.getElementById('selectAllGrids');
      var cbs = document.querySelectorAll('.grid-chk');
      for (var i=0; i<cbs.length; i++){
        if (cbs[i].parentElement && cbs[i].parentElement.style.display !== 'none'){
          cbs[i].checked = source.checked;
        }
      }
    }
    function applyFilter(){
      var cbs = document.querySelectorAll('.grid-chk:checked');
      var arr = [];
      for (var i=0; i<cbs.length; i++){ arr.push(cbs[i].value); }
      selectedGrids = arr;

      alert(
        (selectedGrids.length > 0 ? ('Filtering ' + selectedGrids.length + ' Grids') : 'All Grids Selected') +
        '\n\nFeeders of selected grids will be shown with only direct interconnected feeders'
      );
    }
    function resetFilter(){
      selectedGrids = [];
      var cbs = document.querySelectorAll('.grid-chk');
      for (var i=0; i<cbs.length; i++){ cbs[i].checked = false; }
      var selAll = document.getElementById('selectAllGrids'); if (selAll) selAll.checked = false;
      var inp = document.getElementById('gridSearchInput'); if (inp) inp.value = '';
      filterGridList();
    }

    /* -----------------------------
     * Feeder Search
     * ---------------------------*/
    function fillGridForFeederSearchSelect(){
      var gridSelect = document.getElementById('gridForFeederSearch');
      gridSelect.innerHTML = '<option value="" selected disabled>Choose gridâ€¦</option>';
      var map = {};
      for (var i=1; i<activeProjectData.nodes.length; i++){
        var row = activeProjectData.nodes[i]; if (!row) continue;
        var g = norm(row[4]); if (g) map[g] = true;
      }
      var grids = Object.keys(map).sort();
      for (var k=0; k<grids.length; k++){
        var opt = document.createElement('option'); opt.value = grids[k]; opt.text = grids[k];
        gridSelect.add(opt);
      }
      var feederSelect = document.getElementById('feederList');
      feederSelect.innerHTML = '<option value="" selected disabled>Choose feederâ€¦</option>';
    }

    function populateFeederList(){
      var feederSelect = document.getElementById('feederList');
      feederSelect.innerHTML = '<option value="" selected disabled>Choose feederâ€¦</option>';
      var gridSel = norm(document.getElementById('gridForFeederSearch').value);
      if (!gridSel) return;

      var rows = activeProjectData.nodes.slice(1);
      var seen = {};
      for (var i=0; i<rows.length; i++){
        var r = rows[i]; if (!r) continue;
        var id = norm(r[0]), label = norm(r[1]), grid = norm(r[4]);
        if (!id || !label) continue;
        if (grid === gridSel && !seen[label]) {
          var o = document.createElement('option');
          o.value = id; o.text  = label;
          o.setAttribute('data-label', label);
          o.setAttribute('data-grid', grid);
          feederSelect.add(o);
          seen[label] = true;
        }
      }
    }

    /* -----------------------------
     * Search & highlight
     * ---------------------------*/
    function flickerNode(ele, times){
      if (typeof times === 'undefined') times = 3;
      var count = 0;
      var interval = setInterval(function(){
        ele.toggleClass('cy-highlighted');
        count++;
        if (count >= times*2){ clearInterval(interval); ele.removeClass('cy-highlighted'); }
      }, 250);
    }

    function searchFeeder(){
      if (!activeProjectData.nodes || activeProjectData.nodes.length === 0){
        alert('Please select a project first.'); return;
      }

      var gridSel = norm(document.getElementById('gridForFeederSearch').value);
      var feederList = document.getElementById('feederList');
      if (!feederList || feederList.selectedIndex < 0){
        alert('Select a feeder (node) to search.'); return;
      }

      var selectedLabel = norm(
        feederList.options[feederList.selectedIndex].getAttribute('data-label') ||
        feederList.options[feederList.selectedIndex].text
      );
      var selectedGrid  = norm(
        feederList.options[feederList.selectedIndex].getAttribute('data-grid') ||
        gridSel
      );

      if (!selectedLabel || !selectedGrid){
        alert('Select grid and feeder (node) first.'); return;
      }

      var hasFilter = Array.isArray(selectedGrids) && selectedGrids.length > 0;

      function findCandidatesInCurrentCy(){
        if (!cy) return null;
        var candidates = cy.nodes().filter(function(n){
          var nLabel = norm(n.data('label'));
          var nGrid  = norm(n.data('grid'));
          return (nLabel.toLowerCase() === selectedLabel.toLowerCase()) && (nGrid === selectedGrid);
        });
        if (!candidates || candidates.length === 0){
          candidates = cy.nodes().filter(function(n){
            return norm(n.data('label')).toLowerCase() === selectedLabel.toLowerCase();
          });
        }
        return (candidates && candidates.length > 0) ? candidates : null;
      }

      function highlightInCurrentCyOrWarn(){
        var candidates = findCandidatesInCurrentCy();
        if (candidates){
          var target = candidates[0];
          cy.animate({ center: { eles: target }, zoom: Math.min(2, cy.maxZoom() || 2) }, { duration: 600 });
          flickerNode(target, 3);
          return true;
        } else {
          if (hasFilter){
            alert(
              'A Grid Station filter is active.\n' +
              'The selected feeder is outside the current filter.\n' +
              'Cancel the filter to show this feeder.'
            );
            return false;
          } else {
            alert('Feeder node "' + selectedLabel + '" not found.');
            return false;
          }
        }
      }

      if (hasFilter){
        if (!cy){
          drawGraph();
          if (cy){
            var runAfter = function(){ highlightInCurrentCyOrWarn(); };
            cy.one('layoutstop', runAfter);
          }
        } else {
          highlightInCurrentCyOrWarn();
        }
      } else {
        ensureFullGraphRenderedAsync(function(){
          var candidates = cy.nodes().filter(function(n){
            var nLabel = norm(n.data('label'));
            var nGrid  = norm(n.data('grid'));
            return (nLabel.toLowerCase() === selectedLabel.toLowerCase()) && (nGrid === selectedGrid);
          });
          if (!candidates || candidates.length === 0){
            candidates = cy.nodes().filter(function(n){
              return norm(n.data('label')).toLowerCase() === selectedLabel.toLowerCase();
            });
          }
          if (!candidates || candidates.length === 0){
            alert('Feeder node "' + selectedLabel + '" not found.');
            return;
          }
          var target = candidates[0];
          cy.animate({ center: { eles: target }, zoom: Math.min(2, cy.maxZoom() || 2) }, { duration: 600 });
          flickerNode(target, 3);
        });
      }
    }

    /* -----------------------------
     * Draw graph with current grid filter
     * ---------------------------*/
    function drawGraph(){
      if (!activeProjectData.nodes || activeProjectData.nodes.length === 0) return;

      var data = buildAllElementsFromActiveProject();
      var fn = data.nodes.slice(0);
      var fe = data.edges.slice(0);

      if (selectedGrids.length > 0){
        var primary = {};
        for (var i=0; i<fn.length; i++){ if (selectedGrids.indexOf(fn[i].data.grid) !== -1){ primary[fn[i].data.id] = true; } }
        var linked = {};
        for (var j=0; j<fe.length; j++){
          var e = fe[j].data;
          if (primary[e.source]) linked[e.target] = true;
          if (primary[e.target]) linked[e.source] = true;
        }
        var combined = {};
        for (var k in primary){ combined[k] = true; }
        for (var k2 in linked){ combined[k2] = true; }
        fn = fn.filter(function(n){ return combined[n.data.id]; });
        fe = fe.filter(function(e2){ return combined[e2.data.source] && combined[e2.data.target]; });
      }

      var style = getBaseStyle();
      if (!cy){
        cy = cytoscape({ container: document.getElementById('cy'), elements: { nodes: fn, edges: fe }, style: style, layout: DEFAULT_LAYOUT });
        attachCyTooltipHandlers();
      } else {
        cy.stop(); cy.elements().remove(); cy.style().fromJson(style).update(); cy.add(fn.concat(fe));
        cy.layout(DEFAULT_LAYOUT).run();
        attachCyTooltipHandlers();
      }
    }

    /* ===========================================================
     * Rect Loop â€” tight pack + aggressive zero-crossing pursuit
     * ===========================================================
     * - Center-first (hub-centric) base assignment
     * - Grow grid (rows/cols), reward more lines
     * - Heavy penalty for crossings & node-edge near hits
     * - Post-pass relocation to empty cells
     * - Tight shelf packing to keep loops close
     */

    /* ---------- Geometry helpers (grid coords: x=c, y=r) ---------- */
    function _orient(a, b, c){
      var v = (b.y - a.y)*(c.x - b.x) - (b.x - a.x)*(c.y - b.y);
      if (v === 0) return 0;
      return (v > 0) ? 1 : 2;
    }
    function _onSeg(a, b, c){
      return Math.min(a.x,b.x) <= c.x && c.x <= Math.max(a.x,b.x) &&
             Math.min(a.y,b.y) <= c.y && c.y <= Math.max(a.y,b.y);
    }
    function _segIntersect(p1, p2, p3, p4){
      var o1 = _orient(p1,p2,p3), o2 = _orient(p1,p2,p4), o3 = _orient(p3,p4,p1), o4 = _orient(p3,p4,p2);
      if (o1 !== o2 && o3 !== o4) return true;
      if (o1 === 0 && _onSeg(p1,p2,p3)) return true;
      if (o2 === 0 && _onSeg(p1,p2,p4)) return true;
      if (o3 === 0 && _onSeg(p3,p4,p1)) return true;
      if (o4 === 0 && _onSeg(p3,p4,p2)) return true;
      return false;
    }
    function _distPointSeg(p, a, b){
      var vx = b.x - a.x, vy = b.y - a.y;
      var wx = p.x - a.x, wy = p.y - a.y;
      var c1 = vx*wx + vy*wy;
      if (c1 <= 0) return Math.sqrt(wx*wx + wy*wy);
      var c2 = vx*vx + vy*vy;
      if (c2 <= c1) return Math.sqrt((p.x-b.x)*(p.x-b.x) + (p.y-b.y)*(p.y-b.y));
      var t = c1 / c2;
      var proj = { x: a.x + t*vx, y: a.y + t*vy };
      var dx = p.x - proj.x, dy = p.y - proj.y;
      return Math.sqrt(dx*dx + dy*dy);
    }

    // Crossing detection with sampling for large edge sets (prevents UI freezes)
    function _listCrossings(comp, rcMap){
      var edges = comp.edges();
      var out = [];
      var E = edges.length;

      var MAX_PAIRS = 20000; // cap
      var totalPairs = (E * (E - 1)) / 2;

      if (totalPairs <= MAX_PAIRS){
        for (var i=0; i<E; i++){
          var e1 = edges[i];
          var s1 = rcMap[e1.source().id()], t1 = rcMap[e1.target().id()];
          if (!s1 || !t1) continue;
          var p1 = {x:s1.c, y:s1.r}, p2 = {x:t1.c, y:t1.r};

          for (var j=i+1; j<E; j++){
            var e2 = edges[j];
            var sid1=e1.source().id(), tid1=e1.target().id();
            var sid2=e2.source().id(), tid2=e2.target().id();
            if (sid1===sid2 || sid1===tid2 || tid1===sid2 || tid1===tid2) continue;

            var s2 = rcMap[sid2], t2 = rcMap[tid2];
            if (!s2 || !t2) continue;
            var p3 = {x:s2.c, y:s2.r}, p4 = {x:t2.c, y:t2.r};

            if (_segIntersect(p1,p2,p3,p4)) out.push({e1:e1, e2:e2});
          }
        }
        return out;
      }

      // Sampling (random pairs)
      var SAMPLES = MAX_PAIRS;
      for (var s=0; s<SAMPLES; s++){
        var i = Math.floor(Math.random()*E);
        var j = Math.floor(Math.random()*E);
        if (i === j) continue;
        if (j < i){ var t = i; i = j; j = t; }

        var e1 = edges[i], e2 = edges[j];
        var sid1=e1.source().id(), tid1=e1.target().id();
        var sid2=e2.source().id(), tid2=e2.target().id();
        if (sid1===sid2 || sid1===tid2 || tid1===sid2 || tid1===tid2) continue;

        var s1 = rcMap[sid1], t1 = rcMap[tid1], s2 = rcMap[sid2], t2 = rcMap[tid2];
        if (!s1 || !t1 || !s2 || !t2) continue;
        var p1 = {x:s1.c, y:s1.r}, p2_ = {x:t1.c, y:t1.r}, p3 = {x:s2.c, y:s2.r}, p4 = {x:t2.c, y:t2.r};
        if (_segIntersect(p1,p2_,p3,p4)) out.push({e1:e1, e2:e2});
      }
      return out;
    }

    function _nodeDegreesInComp(comp){
      var deg = {}; var nodes = comp.nodes();
      for (var i=0; i<nodes.length; i++){ deg[nodes[i].id()] = nodes[i].degree(); }
      return deg;
    }

    /* ---------- Center-first cells ---------- */
    function centerFirstCells(rows, cols, snake) {
      var cells = [];
      var cr = (rows - 1) / 2.0, cc = (cols - 1) / 2.0;
      for (var r=0; r<rows; r++){
        for (var c=0; c<cols; c++){
          var cc2 = c;
          if (snake && (r % 2 === 1)) cc2 = (cols - 1) - c;
          var dr = r - cr, dc = cc2 - cc;
          var d2 = dr*dr + dc*dc;
          cells.push({ r:r, c:cc2, d:d2 });
        }
      }
      cells.sort(function(a,b){
        if (a.d !== b.d) return a.d - b.d;
        if (a.r !== b.r) return a.r - b.r;
        return a.c - b.c;
      });
      return cells;
    }

    /* ---------- Cost & candidates ---------- */
    function layoutCost(comp, rcMap, rows, cols, arWeight, lineReward, minDist){
      var edges = comp.edges();
      var len = 0;
      for (var i=0; i<edges.length; i++){
        var e = edges[i];
        var ps = rcMap[e.source().id()], pt = rcMap[e.target().id()];
        if (!ps || !pt) continue;
        len += Math.abs(ps.r - pt.r) + Math.abs(ps.c - pt.c);
      }
      var ratio = (cols > rows) ? (cols/rows) : (rows/cols);
      var arPen = Math.max(0, ratio - 1.0);
      var lineRew = (rows + cols);

      var crossingPairs = _listCrossings(comp, rcMap);
      var cross = crossingPairs.length;

      var nodes = comp.nodes(), nearCnt=0;
      for (var i=0; i<nodes.length; i++){
        var nid = nodes[i].id();
        var p = rcMap[nid]; if (!p) continue;
        var pt = {x:p.c, y:p.r};
        for (var j=0; j<edges.length; j++){
          var e = edges[j];
          var sId=e.source().id(), tId=e.target().id();
          if (sId===nid || tId===nid) continue;
          var a = rcMap[sId], b = rcMap[tId];
          if (!a || !b) continue;
          var pa={x:a.c,y:a.r}, pb={x:b.c,y:b.r};
          var d=_distPointSeg(pt,pa,pb);
          if (d < minDist) nearCnt++;
        }
      }

      var INTER_W = 100000; // force zero crossings if possible
      var NEAR_W  = 5000;

      var cost = len + (arWeight*arPen) - (lineReward*lineRew) + (INTER_W*cross) + (NEAR_W*nearCnt);
      return { cost: cost, crossings: cross, nearHits: nearCnt };
    }

    function candidateGridShapesOptionC(n, maxGrow){
      var res = [];
      var s = Math.ceil(Math.sqrt(n));
      for (var g=0; g<=maxGrow; g++){
        var t = s + g;
        res.push({ rows:t, cols:t });
      }
      for (var g2=0; g2<=maxGrow; g2++){
        var t2 = s + g2;
        var cands = [
          { rows:t2,   cols:t2+1 },
          { rows:t2+1, cols:t2   },
          { rows:t2-1>0?t2-1:t2, cols:t2+1 },
          { rows:t2+1, cols:t2-1>0?t2-1:t2 }
        ];
        for (var ci=0; ci<cands.length; ci++){ res.push({ rows: cands[ci].rows, cols: cands[ci].cols }); }
      }
      var uniq={}, out=[];
      for (var i=0; i<res.length; i++){
        var k=res[i].rows+'x'+res[i].cols; if (!uniq[k]){ uniq[k]=true; out.push(res[i]); }
      }
      return out;
    }

    function improveBySwaps(comp, rcMap, idOrder, rows, cols, arWeight, lineReward, minDist, maxRounds, windowSize){
      if (!idOrder || idOrder.length < 3) return;
      for (var round=0; round<maxRounds; round++){
        var improved = false;
        for (var i=0; i<idOrder.length-1; i++){
          for (var j=i+1; j<Math.min(idOrder.length, i+1+windowSize); j++){
            var idA = idOrder[i], idB = idOrder[j];
            var posA = rcMap[idA], posB = rcMap[idB];
            if (!posA || !posB) continue;

            rcMap[idA]=posB; rcMap[idB]=posA;
            var nEval = layoutCost(comp, rcMap, rows, cols, arWeight, lineReward, minDist);
            rcMap[idA]=posA; rcMap[idB]=posB;
            var oEval = layoutCost(comp, rcMap, rows, cols, arWeight, lineReward, minDist);

            if (nEval.cost < oEval.cost){ rcMap[idA]=posB; rcMap[idB]=posA; improved=true; }
          }
        }
        if (!improved) break;
      }
    }

    function chooseBestGridForComponentOptionC(comp, orderedNodes, arWeight, lineReward, maxGrow, growUntilNoCross, maxGrowLimit, minDist){
      var n = orderedNodes.length;

      // Special: 3â€“4 nodes linear with locked orientation (hub near center along the line)
      if (n === 3 || n === 4){
        var horiz = (smallLoopOrientation === 'horizontal');
        var rows = horiz ? 1 : n;
        var cols = horiz ? n : 1;
        var seq;
        if (n === 3){
          seq = horiz ? [ {r:0,c:1}, {r:0,c:0}, {r:0,c:2} ]
                      : [ {r:1,c:0}, {r:0,c:0}, {r:2,c:0} ];
        } else {
          seq = horiz ? [ {r:0,c:1}, {r:0,c:2}, {r:0,c:0}, {r:0,c:3} ]
                      : [ {r:1,c:0}, {r:2,c:0}, {r:0,c:0}, {r:3,c:0} ];
        }
        var rcMap = {}; var idOrder = [];
        for (var k=0; k<n; k++){ var id=orderedNodes[k].id(); idOrder.push(id); rcMap[id] = { r:seq[k].r, c:seq[k].c }; }
        improveBySwaps(comp, rcMap, idOrder, rows, cols, arWeight, lineReward, minDist, 1, 3);
        var evalRes = layoutCost(comp, rcMap, rows, cols, arWeight, lineReward, minDist);
        return { rows:rows, cols:cols, rcMap:rcMap, eval:evalRes };
      }

      var best = null;
      var grow = maxGrow;

      // Grow until zero-crossings or cap
      while (true){
        var shapes = candidateGridShapesOptionC(n, grow);
        var foundZero = false;

        for (var sIdx=0; sIdx<shapes.length; sIdx++){
          var sh = shapes[sIdx];
          for (var snakeFlag=0; snakeFlag<2; snakeFlag++){
            var cells = centerFirstCells(sh.rows, sh.cols, snakeFlag===1);
            var rcMap = {}; var idOrder = [];
            for (var k=0; k<n; k++){
              var id = orderedNodes[k].id(); idOrder.push(id);
              rcMap[id] = { r: cells[k].r, c: cells[k].c };
            }
            improveBySwaps(comp, rcMap, idOrder, sh.rows, sh.cols, arWeight, lineReward, minDist, 2, 5);

            var evalRes = layoutCost(comp, rcMap, sh.rows, sh.cols, arWeight, lineReward, minDist);
            if (!best || evalRes.cost < best.eval.cost){ best = { rows: sh.rows, cols: sh.cols, rcMap: rcMap, eval: evalRes }; }
            if (evalRes.crossings === 0 && evalRes.nearHits === 0){ foundZero = true; break; }
          }
          if (foundZero) break;
        }

        if (!growUntilNoCross) break;
        if (foundZero) break;
        if (grow >= maxGrowLimit) break;
        grow = Math.min(grow + 4, maxGrowLimit);
      }

      return best;
    }

    /* ---------- Post-pass empty-cell relocation with stagnation guard ---------- */
    function relocateToBreakCrossings(comp, best, minDist, maxMoves){
      var rcMap = best.rcMap;
      var rows = best.rows, cols = best.cols;
      var deg = _nodeDegreesInComp(comp);

      function toKey(r,c){ return r+'_'+c; }
      var occ = {};
      var ids = Object.keys(rcMap);
      for (var i=0; i<ids.length; i++){
        var id=ids[i], rc=rcMap[id]; occ[toKey(rc.r, rc.c)] = id;
      }

      var allCells = [];
      for (var r=0; r<rows; r++){ for (var c=0; c<cols; c++){ allCells.push({r:r,c:c}); } }

      function nearestEmptyCells(fromR, fromC){
        var candidates = [];
        for (var ii=0; ii<allCells.length; ii++){
          var cell = allCells[ii];
          if (!occ[toKey(cell.r,cell.c)]) candidates.push({r:cell.r,c:cell.c, d: Math.abs(cell.r-fromR)+Math.abs(cell.c-fromC) });
        }
        candidates.sort(function(a,b){ return a.d - b.d; });
        return candidates;
      }

      var moves = 0;
      var stagnationRounds = 0;
      var lastCross = _listCrossings(comp, rcMap).length;

      while (moves < maxMoves){
        var crossings = _listCrossings(comp, rcMap);
        var currentCross = crossings.length;

        if (currentCross === 0){
          var nearEval = layoutCost(comp, rcMap, rows, cols, 0, 0, minDist);
          if (nearEval.nearHits === 0) break;
        }

        if (!crossings || crossings.length === 0) break;
        var cross = crossings[0];
        var e1 = cross.e1, e2 = cross.e2;

        var endpoints = [
          e1.source().id(), e1.target().id(),
          e2.source().id(), e2.target().id()
        ];
        endpoints.sort(function(a,b){ return (deg[a]||0) - (deg[b]||0); });

        var moved = false;

        for (var ei=0; ei<endpoints.length && !moved; ei++){
          var nid = endpoints[ei];
          var pos = rcMap[nid]; if (!pos) continue;

          var empties = nearestEmptyCells(pos.r, pos.c);
          for (var ci=0; ci<empties.length; ci++){
            var target = empties[ci];
            var oldKey = toKey(pos.r,pos.c);
            var newKey = toKey(target.r,target.c);

            delete occ[oldKey];
            occ[newKey] = nid;
            rcMap[nid] = { r:target.r, c:target.c };

            var evalRes = layoutCost(comp, rcMap, rows, cols, 0, 0, minDist);
            if (evalRes.crossings === 0 && evalRes.nearHits === 0){
              moved = true; moves++;
              break;
            }

            // revert
            delete occ[newKey];
            occ[oldKey] = nid;
            rcMap[nid] = { r:pos.r, c:pos.c };
          }
        }

        // stagnation guard (avoid infinite work if no improvement)
        var newCross = _listCrossings(comp, rcMap).length;
        if (!moved || newCross >= lastCross){
          stagnationRounds++;
          if (stagnationRounds >= 3) break;
        } else {
          stagnationRounds = 0;
        }
        lastCross = newCross;

        if (!moved) break;
      }

      best.eval = layoutCost(comp, rcMap, rows, cols, 0, 0, minDist);
      return best;
    }

    /* ---------- Tight shelf packing (loops close together) ---------- */
    function packComponentsTightShelves(compsInfo, viewportW, viewportH, margin, minGap){
      var x = margin, y = margin, shelfH = 0;
      var maxW = Math.max(300, viewportW - margin*2);

      for (var i=0; i<compsInfo.length; i++){
        var ci = compsInfo[i];
        var w = Math.ceil(ci.boxW), h = Math.ceil(ci.boxH);
        var gap = minGap;

        if (x + w > maxW + margin){
          x = margin;
          y += shelfH + gap;
          shelfH = 0;
        }

        ci.boxX = x;
        ci.boxY = y;

        x += w + gap;
        if (h > shelfH) shelfH = h;
      }
    }

    function rectangularizeLoops(opts){
      if (!cy) { alert('Please draw the graph first.'); return; }

      opts = opts || {};
      var padding     = (typeof opts.padding     === 'number') ? opts.padding     : 40;
      var stepBase    = (typeof opts.stepBase    === 'number') ? opts.stepBase    : 84;
      var minGap      = (typeof opts.minGap      === 'number') ? opts.minGap      : 36;
      var margin      = (typeof opts.margin      === 'number') ? opts.margin      : 40;
      var animate     = (typeof opts.animate     === 'boolean') ? opts.animate    : true;
      var duration    = (typeof opts.duration    === 'number') ? opts.duration    : 700;
      var arWeight    = (typeof opts.arWeight    === 'number') ? opts.arWeight    : 10;
      var lineReward  = (typeof opts.lineReward  === 'number') ? opts.lineReward  : 3.0;
      var maxGrow     = (typeof opts.maxGrow     === 'number') ? opts.maxGrow     : 10;
      var maxGrowLimit= (typeof opts.maxGrowLimit=== 'number') ? opts.maxGrowLimit: 30;
      var growUntilNoCross = (typeof opts.growUntilNoCross === 'boolean') ? opts.growUntilNoCross : true;
      var minDist     = (typeof opts.minDist     === 'number') ? opts.minDist     : 0.35;
      var relocMoves  = (typeof opts.relocMoves  === 'number') ? opts.relocMoves  : 200;

      // Which components
      var selected = cy.$('node:selected');
      var allComps = cy.elements().components();
      var comps = [];
      if (selected && selected.length > 0) {
        for (var ci = 0; ci < allComps.length; ci++) {
          var compNodes = allComps[ci].nodes();
          var inter = compNodes.intersect(selected);
          if (inter && inter.length > 0) comps.push(allComps[ci]);
        }
      } else {
        comps = allComps;
      }
      if (!comps || comps.length === 0) return;

      var viewportW = cy.width();
      var viewportH = cy.height();

      // Largest first
      comps = comps.sort(function(a,b){ return b.nodes().length - a.nodes().length; });

      var plan = [];
      for (var i=0; i<comps.length; i++){
        var comp = comps[i];
        var nodes = comp.nodes();
        if (!nodes || nodes.length === 0) continue;

        var ordered = bfsOrderWithin(nodes);

        var best = chooseBestGridForComponentOptionC(
          comp, ordered, arWeight, lineReward, maxGrow, growUntilNoCross, maxGrowLimit, minDist
        );

        best = relocateToBreakCrossings(comp, best, minDist, relocMoves);

        var density = Math.max(1, comp.edges().length / Math.max(1, nodes.length));
        var step = stepBase + Math.min(48, Math.floor(8 * density));
        var sx = step, sy = step;

        var innerW = (best.cols > 1) ? (best.cols - 1) * sx : 0;
        var innerH = (best.rows > 1) ? (best.rows - 1) * sy : 0;

        plan.push({
          comp: comp,
          ordered: ordered,
          best: best,
          stepX: sx,
          stepY: sy,
          boxW: innerW + padding*2,
          boxH: innerH + padding*2
        });
      }

      packComponentsTightShelves(plan, viewportW, viewportH, margin, minGap);

      var targetPositions = {};
      for (var p=0; p<plan.length; p++){
        var pi = plan[p];
        var startX = pi.boxX + padding;
        var startY = pi.boxY + padding;
        var rows = pi.best.rows, cols = pi.best.cols, sx = pi.stepX, sy = pi.stepY;
        var nlist = pi.ordered;
        var rcMap = pi.best.rcMap;

        for (var k=0; k<nlist.length; k++){
          var id = nlist[k].id();
          var rc = rcMap[id];
          var x = startX + rc.c * sx;
          var y = startY + rc.r * sy;
          targetPositions[id] = { x:x, y:y };
        }
      }

      cy.batch(function(){
        for (var id in targetPositions) {
          if (!targetPositions.hasOwnProperty(id)) continue;
          cy.getElementById(id).position(targetPositions[id]);
        }
      });

      if (animate) {
        cy.animate({ fit: { eles: cy.elements(), padding: 40 } }, { duration: duration });
      }
    }

    /* -----------------------------
     * Export
     * ---------------------------*/
    function dataURItoBlob(dataURI){
      var parts = dataURI.split(',');
      var mime = parts[0].match(/:(.*?);/)[1];
      var byteString = atob(parts[1]);
      var ab = new ArrayBuffer(byteString.length);
      var ia = new Uint8Array(ab);
      for (var i=0; i<byteString.length; i++) ia[i] = byteString.charCodeAt(i);
      return new Blob([ab], { type: mime });
    }
    function exportPng(){ if (!cy) return; var dataUrl = cy.png({ full:true, scale:2 }); var blob = dataURItoBlob(dataUrl); saveAs(blob, 'Network_Export.png'); }
    function exportPdf(){ if (!cy) return; var dataUrl = cy.png({ full:true, scale:1.5 }); pdfMake.createPdf({ content:[{ image:dataUrl, width:500 }] }).download('SLD_Report.pdf'); }

    /* -----------------------------
     * Project selection & preload
     * ---------------------------*/
    function onProjectSelect(){
      var pName = document.getElementById('projectList').value; activeProjectName = pName;
      var cached = projectDataCache[pName];
      if (!cached || !cached.nodes || cached.nodes.length===0 || !cached.edges || cached.edges.length===0){
        setStatus('File mismatch (Check names) âŒ'); return;
      }
      activeProjectData.nodes = cached.nodes; activeProjectData.edges = cached.edges;
      renderGridFilters();
      fillGridForFeederSearchSelect();
      document.getElementById('drawBtn').disabled = false;
      setStatus(pName + ' Ready  âœ…');
    }

    document.addEventListener('DOMContentLoaded', function(){
      // Grid filter
      document.getElementById('gridSearchInput').addEventListener('input', filterGridList);
      document.getElementById('selectAllGrids').addEventListener('click', toggleSelectAllHandler);
      document.getElementById('applyFilterBtn').addEventListener('click', applyFilter);
      document.getElementById('resetFilterBtn').addEventListener('click', resetFilter);

      // Feeder search
      document.getElementById('gridForFeederSearch').addEventListener('change', populateFeederList);
      document.getElementById('searchFeederBtn').addEventListener('click', searchFeeder);

      // Graph & export
      document.getElementById('drawBtn').addEventListener('click', drawGraph);
      document.getElementById('exportPngBtn').addEventListener('click', exportPng);
      document.getElementById('exportPdfBtn').addEventListener('click', exportPdf);

      // Orientation toggle for 3â€“4 feeders
      var radios = document.querySelectorAll('input[name="smallLoopOrient"]');
      for (var i=0; i<radios.length; i++){
        radios[i].addEventListener('change', function(e){
          smallLoopOrientation = e.target.value;
        });
      }

      // Rect Loop: read sliders, apply
      document.getElementById('rectifyLoopsBtn').addEventListener('click', function(){
        var minGapVal = parseInt(document.getElementById('ui_minGap').value, 10);
        var maxGrowLimitVal = parseInt(document.getElementById('ui_maxGrowLimit').value, 10);
        var relocMovesVal = parseInt(document.getElementById('ui_relocMoves').value, 10);

        rectangularizeLoops({
          padding: 40,
          stepBase: 84,
          minGap: minGapVal,          // â† "Loop Spacing"
          margin: 40,
          animate: true,
          duration: 720,
          arWeight: 10,
          lineReward: 3.0,
          maxGrow: 10,
          maxGrowLimit: maxGrowLimitVal, // â† "Grid Expansion Limit"
          growUntilNoCross: true,
          minDist: 0.35,
          relocMoves: relocMovesVal      // â† "Autoâ€‘Fix Depth"
        });
      });

      // Project selection
      document.getElementById('projectList').addEventListener('change', onProjectSelect);

      // Preload projects
      var preloadStatus = document.getElementById('preloadStatus');
      var projectList = document.getElementById('projectList');

      fetchTextOrThrow('projects.csv').then(function(projectsCSV){
        var parsed = parseCSVToArray(projectsCSV);
        var projectNames = [];
        for (var i=1; i<parsed.length; i++){ if (parsed[i] && parsed[i][0]) projectNames.push(norm(parsed[i][0])); }
        projectList.innerHTML = '<option value="" disabled selected>Select a Project...</option>';
        for (var p=0; p<projectNames.length; p++){
          var name = projectNames[p]; var opt = document.createElement('option'); opt.value = name; opt.text = name; projectList.add(opt);
        }
        setStatus('Data Loaded âœ…');
        preloadStatus.innerText = 'Preloading ' + projectNames.length + ' project(s)...';

        var idx = 0;
        function preloadNext(){
          if (idx >= projectNames.length){ preloadStatus.innerText = ' Ready âœ…'; return; }
          var pName = projectNames[idx++];
          Promise.all([ fetchTextOrThrow(pName+'nodes.csv'), fetchTextOrThrow(pName+'edges.csv') ])
            .then(function(res){
              projectDataCache[pName] = { nodes: parseCSVToArray(res[0]), edges: parseCSVToArray(res[1]) };
              preloadStatus.innerText = 'Preloaded ' + idx + '/' + projectNames.length + ': "' + pName + '" âœ…';
              preloadNext();
            })
            .catch(function(err){
              console.error('Preload error for project "'+pName+'":', err);
              projectDataCache[pName] = { nodes: [], edges: [] };
              preloadStatus.innerText = 'Preloaded ' + (idx-1) + '/' + projectNames.length + ' (some projects missing files) âš ï¸';
              preloadNext();
            });
        }
        preloadNext();
      }).catch(function(err){
        console.error('Fetch Error:', err);
      });
    });
  </script>
</body>
</html>